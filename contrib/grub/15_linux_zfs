#! /bin/sh
set -e

. "/usr/share/grub/grub-mkconfig_lib"

set -u

# grub-mkconfig helper script.

#
#  PSEUDOCODE from the spec - Remove once implemented
#
# For each pool on the system
# identify root datasets.
# For each root dataset
    # Retrieve /etc/machine-id (/!\ etc can be a children datasets, which is fine as long as it’s in ROOT/)
    # Retrieve /etc/os-release (Add support to os-prober?)
    # Retrieve user property org.zsys:last-used from the dataset.
    # Retrieve snapshots from the datasets.
# For each machine-id:
    # If zsys:
        # sort(datasets by last-used or snapshot timestamp) desc order
    # else:
        # datasets = [dataset (first) which has mountpoint != legacy and != none] (not coming from a cloned snapshot) + [snapshots of that dataset, ordered by snapshot name]
    # print(“os-released” os-probed) of datasets[0]
        # rpool=dataset_path
    # print(“os-released” os-probed) of datasets[0]
        # rpool=dataset_pat
        # option recovery mode
    # print(History)
        # [SUBMENU]
        # for each dataset in datasets[1..]:
            # print (revert to %s timestamp) + if os-probed_name != datasets[0] os-probed-name -> print os-probed_name
            # [SUBMENU]
            # Revert system
                # rpool=data_path (including @snapshot)
            # Revert system (recovery mode)
                # rpool=data_path (including @snapshot)
                # option recovery mode
    # date -d @timestamp -> to convert to current timezone human readable date

# If current system is zfs with zsys: disable 10_linux.

initial_pools=$(zpool list | awk '{if (NR>1) print $1}')
MNTDIR=$(mktemp -d ${TMPDIR:-/tmp}/zfsmnt.XXXXXX)


RC=0
on_exit() {
    # Restore initial zpool import state
    for pool in $(get_pools); do
        if ! echo "${initial_pools}" | grep -qw "${pool}"; then
            zpool export "${pool}"
        fi
    done

    mountpoint -q "${MNTDIR}"  && umount "${MNTDIR}" || true
    rmdir "${MNTDIR}"
    exit "${RC}"
}
trap on_exit EXIT INT QUIT ABRT PIPE TERM

# List ONLINE and DEGRADED pools
get_pools() {
    # We have to ignore zpool import output, as potentially multiple / will be available,
    # and we need to autodetect all zpools this way with their real mountpoints.
    zpool import -a -d $HOME 2>/dev/null || true  # TODO: remove -d $HOME
    zpool list | awk '{if (NR>1) print $1}'
}

# List all the dataset with a root mountpoint
get_root_datasets() {
    #zpool/ROOT/
    #/!\ -> /etc
    zfs list -H -oname,canmount,mountpoint -t filesystem | awk '/\t(on|noauto)\t\/$/ {print $1}'
}

# find if given datasets can be mounted for directory and return its path (snapshot or real path)
# $1 is our current dataset name
# $2 directory path we look for (cannot contains /)
# $3 is the temporary mount directory to use
# $4 is the optional snapshot name
# return path for directory (which can be a mountpoint)
validate_system_dataset() {
    local dataset="$1"
    local directory="$2"
    local mntdir="$3"
    local snapshot_name="$4"

    local mount_path="${mntdir}/${directory}"

    if zfs list "${dataset}" >/dev/null 2>&1; then
        if ! mount -o zfsutil -t zfs "${dataset}" "${mount_path}"; then
            grub_warn "Failed to find a valid directory '${directory}' for dataset '${dataset}@${snapshot_name}'. Ignoring"
            return
        fi
    fi

    local candidate_path="${mount_path}"
    if [ -n "${snapshot_name}" ]; then
        candidate_path="${candidate_path}/.zfs/snapshot/${snapshot_name}"
        if ! mountpoint -q "${mount_path}"; then
            candidate_path="${candidate_path}/${directory}"
        fi
    fi

    if [ -n "$(ls ${candidate_path} 2>/dev/null)" ]; then
        echo "${candidate_path}"
        return
    else
        mountpoint -q "${mount_path}" && umount "${mount_path}" || true
    fi
}

# Detect system directory relevant to the other, trying to find the ones associated on the current dataset or snapshot/
# System directory should be at most a direct child dataset of main datasets (no recursivity)
# We can fallback trying other zfs pools if no match has been found.
# $1 is our current dataset name (which can have @snapshot name)
# $2 directory path we look for (cannot contains /)
# $3 is the temporary mount directory to use
# $4 is the optional etc directory (if not $2 is not etc itself)
# return path for directory (which can be a mountpoint)
get_system_directory() {
    local dataset_path="$1"
    local directory="$2"
    local mntdir="$3"
    local etc_dir="$4"

    if [ -z "${etc_dir}" ]; then
        etc_dir="${mntdir}/etc"
    fi

    local candidate_path="${mntdir}/${directory}"

    # 1. Look for /etc/fstab first (which will mount even on top of non empty $directory)
    local directory_in_fstab="false"
    if [ -f "${etc_dir}/fstab" ]; then
        mount_args=$(awk '/^[^#].*\s\/'"${directory}"'\s/ {print "-t", $3, $1}' "${etc_dir}/fstab")
        if [ -n "${mount_args}" ]; then
            mount ${mount_args} "${candidate_path}"
            directory_in_fstab="true"
        fi
    fi

    # If directory isn't empty. Only count if coming from /etc/fstab. Will be
    # handled below otherwise as we are interested in potential snapshots.
    if [ "${directory_in_fstab}" = "true" -a -n "$(ls ${candidate_path} 2>/dev/null)" ]; then
        echo "${candidate_path}"
        return
    fi

    # 2. Handle zfs case, which can be a snapshots.

    local base_dataset_path="${dataset_path}"
    local snapshot_name=""
    # For snapshots we extract the parent dataset
    if echo ${dataset_path} | grep -q '@'; then
        base_dataset_path=$(echo ${dataset_path}|cut -d '@' -f1)
        snapshot_name=$(echo ${dataset_path}|cut -d '@' -f2)
    fi
    base_dataset_name="${base_dataset_path##*/}"
    base_pool="$(echo "${base_dataset_path}" | cut -d'/' -f1)"

    # 2.a) Look for child dataset included in base dataset, which needs to hold same snapshot if any
    candidate_path=$(validate_system_dataset "${base_dataset_path}/${directory}" "${directory}" "${mntdir}" "${snapshot_name}")
    if [ -n "${candidate_path}" ]; then
        echo "${candidate_path}"
        return
    fi

    # 2.b) Look for current dataset (which is already mounted as /)
    candidate_path="${mntdir}/${directory}"
    if [ -n "${snapshot_name}" ]; then
        candidate_path="${mntdir}/.zfs/snapshot/${snapshot_name}/${directory}"
    fi
    if [ -n "$(ls ${candidate_path} 2>/dev/null)" ]; then
        echo "${candidate_path}"
        return
    fi

    # 2.c) Look for every datatsets in every pool (starting with current pool) which holds:
    # - the same dataset name than our base_dataset_name
    # - mountpoint=directory
    # - canmount!=off
    all_basename_datasets="$(zfs list -t filesystem -oname,canmount,mountpoint | awk  '/^[^ ]+\/'"${base_dataset_name}"'\s+(on|noauto)\s+\/'"${directory}"'/ {print $1}')"
    # Start with current pool
    for dataset in $(echo "${all_basename_datasets}" | grep -E "^$base_pool"); do
        candidate_path=$(validate_system_dataset "${dataset}" "${directory}" "${mntdir}" "${snapshot}")
        if [ -n "${candidate_path}" ]; then
            echo "${candidate_path}"
            return
        fi
    done
    # Now check other pools
    for dataset in $(echo "${all_basename_datasets}" | grep -vE "^$base_pool"); do
        candidate_path=$(validate_system_dataset "${dataset}" "${directory}" "${mntdir}" "${snapshot}")
        if [ -n "${candidate_path}" ]; then
            echo "${candidate_path}"
            return
        fi
    done

    # 2.d) If we didn't find anything yet: check for persistent directories; no snapshot associated:
    all_persistent_datasets="$(zfs list -t filesystem -oname,canmount,mountpoint | awk  '/^[^ ]+\s+on\s+\/'"${directory}"'/ {print $1}')"
    # Start with current pool
    for dataset in $(echo "${all_basename_datasets}" | grep -E "^$base_pool"); do
        candidate_path=$(validate_system_dataset "${dataset}" "${directory}" "${mntdir}" "")
        if [ -n "${candidate_path}" ]; then
            echo "${candidate_path}"
            return
        fi
    done
    # Now check other pools
    for dataset in $(echo "${all_basename_datasets}" | grep -vE "^$base_pool"); do
        candidate_path=$(validate_system_dataset "${dataset}" "${directory}" "${mntdir}" "")
        if [ -n "${candidate_path}" ]; then
            echo "${candidate_path}"
            return
        fi
    done

    grub_warn "Failed to find a valid directory '${directory}' for dataset '${dataset_path}'. Ignoring"
    return
}


# Given a filesystem or snapshot dataset, returns dataset|machine id|pretty name|last used
# $1 is dataset we want information from
# $2 is the temporary mount directory to use
get_dataset_info() {
    local dataset="$1"
    local mntdir="$2"

    local base_dataset="${dataset}"
    local etc_dir="${mntdir}/etc"
    local is_snapshot="false"
    # For snapshot we extract the parent dataset
    if echo ${dataset}|grep -q '@'; then
        base_dataset=$(echo ${dataset}|cut -d '@' -f1)
        is_snapshot="true"
    fi

    mount -o zfsutil -t zfs "${base_dataset}" "${mntdir}"

    # read machine-id/os-release from /etc
    etc_dir=$(get_system_directory "${dataset}" "etc" "${mntdir}" "")
    if [ -z  "${etc_dir}" ]; then
        grub_warn "Ignoring ${dataset}"
        mountpoint -q ${mntdir}/etc && umount "${mntdir}/etc" || true
        umount "${mntdir}"
        return
    fi

    machine_id=`cat "${etc_dir}"/machine-id`
    pretty_name=`( . "${etc_dir}"/os-release && echo $PRETTY_NAME )`

    # snapshot: last_used is dataset creation time
    if [ "${is_snapshot}" = "true" ]; then
        creation_date="$(LC_TIME=posix TZ=Etc/UTC zfs get -H creation "${dataset}" | awk -F '\t' '{print $3}')"
        # Convert to epoch
        last_used=$(date -d "${creation_date}" +%s)
    # otherwise, last_used is manually marked at boot/shutdown on a root dataset by zsys or - for non zsys
    else
        last_used=$(zfs get -H org.zsys:last-used "${dataset}" | awk '{print $3}')
    fi

    echo "${dataset}|${machine_id}|${pretty_name}|${last_used}"

    mountpoint -q ${mntdir}/etc && umount "${mntdir}/etc" || true
    umount "${mntdir}" || true
}

# Import all available pools on the system
_=$(get_pools)

BOOTLIST=""
for dataset in $(get_root_datasets); do
    # get information from current root dataset
    BOOTLIST="${BOOTLIST}$(get_dataset_info ${dataset} ${MNTDIR})\n"

    # get information from snapshots of this root dataset
    for snapshot_dataset in $(zfs list -r -H -oname -t snapshot "${dataset}" | grep "${dataset}"@); do
        BOOTLIST="${BOOTLIST}$(get_dataset_info ${snapshot_dataset} ${MNTDIR})\n"
    done
done

echo $BOOTLIST