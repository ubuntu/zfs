#! /bin/sh
set -e

. "/usr/share/grub/grub-mkconfig_lib"

set -u

# grub-mkconfig helper script.

#
#  PSEUDOCODE from the spec - Remove once implemented
#
# For each pool on the system
# identify root datasets.
# For each root dataset
    # Retrieve /etc/machine-id (/!\ etc can be a children datasets, which is fine as long as it’s in ROOT/)
    # Retrieve /etc/os-release (Add support to os-prober?)
    # Retrieve user property org.zsys:last-used from the dataset.
    # Retrieve snapshots from the datasets.
# For each machine-id:
    # If zsys:
        # sort(datasets by last-used or snapshot timestamp) desc order
    # else:
        # datasets = [dataset (first) which has mountpoint != legacy and != none] (not coming from a cloned snapshot) + [snapshots of that dataset, ordered by snapshot name]
    # print(“os-released” os-probed) of datasets[0]
        # rpool=dataset_path
    # print(“os-released” os-probed) of datasets[0]
        # rpool=dataset_pat
        # option recovery mode
    # print(History)
        # [SUBMENU]
        # for each dataset in datasets[1..]:
            # print (revert to %s timestamp) + if os-probed_name != datasets[0] os-probed-name -> print os-probed_name
            # [SUBMENU]
            # Revert system
                # rpool=data_path (including @snapshot)
            # Revert system (recovery mode)
                # rpool=data_path (including @snapshot)
                # option recovery mode
    # date -d @timestamp -> to convert to current timezone human readable date

# If current system is zfs with zsys: disable 10_linux.

initial_pools=$(zpool list | awk '{if (NR>1) print $1}')
MNTDIR=$(mktemp -d ${TMPDIR:-/tmp}/zfsmnt.XXXXXX)


RC=0
on_exit() {
    # Restore initial zpool import state
    for pool in $(get_pools); do
        if ! echo "${initial_pools}" | grep -qw "${pool}"; then
            zpool export "${pool}"
        fi
    done

    mountpoint -q "${MNTDIR}"  && umount "${MNTDIR}" || true
    rmdir "${MNTDIR}"
    exit "${RC}"
}
trap on_exit EXIT INT QUIT ABRT PIPE TERM

# List ONLINE and DEGRADED pools
get_pools() {
    # We have to ignore zpool import output, as potentially multiple / will be available,
    # and we need to autodetect all zpools this way with their real mountpoints.
    zpool import -a -N -d $HOME 2>/dev/null || true  # TODO: remove -d $HOME
    zpool list | awk '{if (NR>1) print $1}'
}

# List all the dataset with a root mountpoint
get_root_datasets() {
    #zpool/ROOT/
    #/!\ -> /etc
    zfs list -H -oname,canmount,mountpoint -t filesystem | awk '/\t(on|noauto)\t\/$/ {print $1}'
}

# find if given datasets can be mounted for directory and return its path (snapshot or real path)
# $1 is our current dataset name
# $2 directory path we look for (cannot contains /)
# $3 is the temporary mount directory to use
# $4 is the optional snapshot name
# return path for directory (which can be a mountpoint)
validate_system_dataset() {
    local dataset="$1"
    local directory="$2"
    local mntdir="$3"
    local snapshot_name="$4"

    local mount_path="${mntdir}/${directory}"

    if zfs list "${dataset}" >/dev/null 2>&1; then
        if ! mount -o zfsutil -t zfs "${dataset}" "${mount_path}"; then
            grub_warn "Failed to find a valid directory '${directory}' for dataset '${dataset}@${snapshot_name}'. Ignoring"
            return
        fi
    fi

    local candidate_path="${mount_path}"
    if [ -n "${snapshot_name}" ]; then
        candidate_path="${candidate_path}/.zfs/snapshot/${snapshot_name}"
        if ! mountpoint -q "${mount_path}"; then
            candidate_path="${candidate_path}/${directory}"
        fi
    fi

    if [ -n "$(ls ${candidate_path} 2>/dev/null)" ]; then
        echo "${candidate_path}"
        return
    else
        mountpoint -q "${mount_path}" && umount "${mount_path}" || true
    fi
}

# Detect system directory relevant to the other, trying to find the ones associated on the current dataset or snapshot/
# System directory should be at most a direct child dataset of main datasets (no recursivity)
# We can fallback trying other zfs pools if no match has been found.
# $1 is our current dataset name (which can have @snapshot name)
# $2 directory path we look for (cannot contains /)
# $3 restrict_to_same_pool (true|false) force looking for dataset with the same basename in the current dataset pool only
# $4 is the temporary mount directory to use
# $5 is the optional etc directory (if not $2 is not etc itself)
# return path for directory (which can be a mountpoint)
get_system_directory() {
    local dataset_path="$1"
    local directory="$2"
    local restrict_to_same_pool="$3"
    local mntdir="$4"
    local etc_dir="$5"

    if [ -z "${etc_dir}" ]; then
        etc_dir="${mntdir}/etc"
    fi

    local candidate_path="${mntdir}/${directory}"

    # 1. Look for /etc/fstab first (which will mount even on top of non empty $directory)
    local directory_in_fstab="false"
    if [ -f "${etc_dir}/fstab" ]; then
        mount_args=$(awk '/^[^#].*\s\/'"${directory}"'\s/ {print "-t", $3, $1}' "${etc_dir}/fstab")
        if [ -n "${mount_args}" ]; then
            mount ${mount_args} "${candidate_path}"
            directory_in_fstab="true"
        fi
    fi

    # If directory isn't empty. Only count if coming from /etc/fstab. Will be
    # handled below otherwise as we are interested in potential snapshots.
    if [ "${directory_in_fstab}" = "true" -a -n "$(ls ${candidate_path} 2>/dev/null)" ]; then
        echo "${candidate_path}"
        return
    fi

    # 2. Handle zfs case, which can be a snapshots.

    local base_dataset_path="${dataset_path}"
    local snapshot_name=""
    # For snapshots we extract the parent dataset
    if echo ${dataset_path} | grep -q '@'; then
        base_dataset_path=$(echo ${dataset_path}|cut -d '@' -f1)
        snapshot_name=$(echo ${dataset_path}|cut -d '@' -f2)
    fi
    base_dataset_name="${base_dataset_path##*/}"
    base_pool="$(echo "${base_dataset_path}" | cut -d'/' -f1)"

    # 2.a) Look for child dataset included in base dataset, which needs to hold same snapshot if any
    candidate_path=$(validate_system_dataset "${base_dataset_path}/${directory}" "${directory}" "${mntdir}" "${snapshot_name}")
    if [ -n "${candidate_path}" ]; then
        echo "${candidate_path}"
        return
    fi

    # 2.b) Look for current dataset (which is already mounted as /)
    candidate_path="${mntdir}/${directory}"
    if [ -n "${snapshot_name}" ]; then
        candidate_path="${mntdir}/.zfs/snapshot/${snapshot_name}/${directory}"
    fi
    if [ -n "$(ls ${candidate_path} 2>/dev/null)" ]; then
        echo "${candidate_path}"
        return
    fi

    # 2.c) Look for every datatsets in every pool (starting with current pool) which holds:
    # - the same dataset name than our base_dataset_name
    # - mountpoint=directory
    # - canmount!=off
    all_basename_datasets="$(zfs list -t filesystem -oname,canmount,mountpoint | awk  '/^[^ ]+\/'"${base_dataset_name}"'\s+(on|noauto)\s+\/'"${directory}"'/ {print $1}')"
    # Start with current pool
    for dataset in $(echo "${all_basename_datasets}" | grep -E "^$base_pool"); do
        candidate_path=$(validate_system_dataset "${dataset}" "${directory}" "${mntdir}" "${snapshot_name}")
        if [ -n "${candidate_path}" ]; then
            echo "${candidate_path}"
            return
        fi
    done

    # Now check other pools
    if [ "${restrict_to_same_pool}" != "true" ]; then
        for dataset in $(echo "${all_basename_datasets}" | grep -vE "^$base_pool"); do
            candidate_path=$(validate_system_dataset "${dataset}" "${directory}" "${mntdir}" "${snapshot_name}")
            if [ -n "${candidate_path}" ]; then
                echo "${candidate_path}"
                return
            fi
        done
    fi

    # 2.d) If we didn't find anything yet: check for persistent directories corresponding to our mountpoint, with canmount=on without any snapshot associated:
    all_persistent_datasets="$(zfs list -t filesystem -oname,canmount,mountpoint | awk  '/^[^ ]+\s+on\s+\/'"${directory}"'/ {print $1}')"
    # Start with current pool
    for dataset in $(echo "${all_persistent_datasets}" | grep -E "^$base_pool"); do
        candidate_path=$(validate_system_dataset "${dataset}" "${directory}" "${mntdir}" "")
        if [ -n "${candidate_path}" ]; then
            echo "${candidate_path}"
            return
        fi
    done
    # Now check other pools
    for dataset in $(echo "${all_persistent_datasets}" | grep -vE "^$base_pool"); do
        candidate_path=$(validate_system_dataset "${dataset}" "${directory}" "${mntdir}" "")
        if [ -n "${candidate_path}" ]; then
            echo "${candidate_path}"
            return
        fi
    done

    grub_warn "Failed to find a valid directory '${directory}' for dataset '${dataset_path}'. Ignoring"
    return
}


# Given a filesystem or snapshot dataset, returns dataset|machine id|pretty name|last used
# $1 is dataset we want information from
# $2 is the temporary mount directory to use
get_dataset_info() {
    local dataset="$1"
    local mntdir="$2"

    local base_dataset="${dataset}"
    local etc_dir="${mntdir}/etc"
    local is_snapshot="false"
    # For snapshot we extract the parent dataset
    if echo ${dataset}|grep -q '@'; then
        base_dataset=$(echo ${dataset}|cut -d '@' -f1)
        is_snapshot="true"
    fi

    mount -o zfsutil -t zfs "${base_dataset}" "${mntdir}"

    # read machine-id/os-release from /etc
    etc_dir=$(get_system_directory "${dataset}" "etc" "true" "${mntdir}" "")
    if [ -z  "${etc_dir}" ]; then
        grub_warn "Ignoring ${dataset}"
        mountpoint -q ${mntdir}/etc && umount "${mntdir}/etc" || true
        umount "${mntdir}"
        return
    fi

    machine_id=`cat "${etc_dir}"/machine-id`
    pretty_name=`( . "${etc_dir}"/os-release && echo $PRETTY_NAME )`
    mountpoint -q ${mntdir}/etc && umount "${mntdir}/etc" || true

    # read available kernels from /boot
    boot_dir=$(get_system_directory "${dataset}" "boot" "false" "${mntdir}" "${etc_dir}")
    if [ -z  "${boot_dir}" ]; then
        grub_warn "Ignoring ${dataset}"
        mountpoint -q ${mntdir}/boot && umount "${mntdir}/boot" || true
        umount "${mntdir}"
        return
    fi

    machine=`uname -m`
    case "$machine" in
        i?86) GENKERNEL_ARCH="x86" ;;
        mips|mips64) GENKERNEL_ARCH="mips" ;;
        mipsel|mips64el) GENKERNEL_ARCH="mipsel" ;;
        arm*) GENKERNEL_ARCH="arm" ;;
        *) GENKERNEL_ARCH="$machine" ;;
    esac

    initrd_list=""
    kernel_list=""
    for linux in $(find $boot_dir -maxdepth 1 -type f -regex '.*/\(vmlinuz\|vmlinux\|kernel\)-.*'|sort -V); do
        if ! grub_file_is_not_garbage "$linux" ; then
            continue
        fi

        # filters entry if efi/non efi
        case $linux in
            *.efi.signed)
                if ! test -d /sys/firmware/efi; then
                    continue
                fi
            ;;
            *)
                if test -d /sys/firmware/efi; then
                    continue
                fi
            ;;
        esac

        linux_basename=`basename $linux`
        linux_dirname=`dirname $linux`
        version=`echo $linux_basename | sed -e "s,^[^0-9]*-,,g"`
        alt_version=`echo $version | sed -e "s,\.old$,,g"`

        gettext_printf "Found linux image: %s in %s\n" "${linux_basename}" "${dataset}" >&2

        initrd=
        for i in "initrd.img-${version}" "initrd-${version}.img" "initrd-${version}.gz" \
            "initrd-${version}" "initramfs-${version}.img" \
            "initrd.img-${alt_version}" "initrd-${alt_version}.img" \
            "initrd-${alt_version}" "initramfs-${alt_version}.img" \
            "initramfs-genkernel-${version}" \
            "initramfs-genkernel-${alt_version}" \
            "initramfs-genkernel-${GENKERNEL_ARCH}-${version}" \
            "initramfs-genkernel-${GENKERNEL_ARCH}-${alt_version}"; do
            if test -e "${linux_dirname}/${i}" ; then
                initrd="$i"
                break
            fi
        done

        if test -z "${initrd}" ; then
            grub_warn "Couldn't find any valid initrd for dataset ${dataset}."
            continue
        fi

        gettext_printf "Found initrd image: %s in %s\n" "${initrd}" "${dataset}" >&2

        rel_linux_dirname=`make_system_path_relative_to_its_root $linux_dirname`

        initrd_list="${rel_linux_dirname}/${initrd}|${initrd_list}"
        kernel_list="${rel_linux_dirname}/${linux_basename}|${kernel_list}"
    done

    initrd_list=${initrd_list%|}
    kernel_list=${kernel_list%|}

    initrd_device=`${grub_probe} --target=device ${boot_dir}`

    mountpoint -q ${mntdir}/boot && umount "${mntdir}/boot" || true

    # for zsys snapshots: we want to know which kernel we successful last booted with
    last_booted_kernel=$(zfs get -H org.zsys:last-booted-kernel "${dataset}" | awk '{print $3}')

    # snapshot: last_used is dataset creation time
    if [ "${is_snapshot}" = "true" ]; then
        creation_date="$(LC_TIME=posix TZ=Etc/UTC zfs get -H creation "${dataset}" | awk -F '\t' '{print $3}')"
        # Convert to epoch
        last_used=$(date -d "${creation_date}" +%s)
    # otherwise, last_used is manually marked at boot/shutdown on a root dataset by zsys or - for non zsys
    else
        last_used=$(zfs get -H org.zsys:last-used "${dataset}" | awk '{print $3}')
    fi

    if [ -n "${initrd_list}" -a -n "${kernel_list}" ]; then
        echo "${dataset}\t${machine_id}\t${pretty_name}\t${last_used}\t${initrd_device}\t${initrd_list}\t${kernel_list}\t${last_booted_kernel}"
    else
        grub_warn "didn't find any valid initrd or kernel."
    fi

    umount "${mntdir}" || true
}

# Scan available boot options and returns in a formatted list
# $1 is the temporary mount directory to use
bootlist() {
    local mntdir="$1"
    local boot_list=""

    for dataset in $(get_root_datasets); do
        # get information from current root dataset
        boot_list="${boot_list}$(get_dataset_info ${dataset} ${mntdir})\n"

        # get information from snapshots of this root dataset
        for snapshot_dataset in $(zfs list -r -H -oname -t snapshot "${dataset}" | grep "${dataset}"@); do
            boot_list="${boot_list}$(get_dataset_info ${snapshot_dataset} ${mntdir})\n"
        done
    done
    echo "${boot_list}"
}

# Import all available pools on the system
_=$(get_pools)

BOOTLIST=$(bootlist ${MNTDIR})

GRUB_LINUX_ZFS_EXPORT_BOOTLIST=${GRUB_LINUX_ZFS_EXPORT_BOOTLIST:-}
if [ -n "${GRUB_LINUX_ZFS_EXPORT_BOOTLIST}" ]; then
    echo "${BOOTLIST}" > ${GRUB_LINUX_ZFS_EXPORT_BOOTLIST}
    return
fi
